// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class FundingRateModel__getNextFundingRateInputPrevStateStruct extends ethereum.Tuple {
  get timestamp(): BigInt {
    return this[0].toBigInt();
  }

  get longOpenInterest(): BigInt {
    return this[1].toBigInt();
  }

  get shortOpenInterest(): BigInt {
    return this[2].toBigInt();
  }

  get fundingRate(): BigInt {
    return this[3].toBigInt();
  }
}

export class FundingRateModel extends ethereum.SmartContract {
  static bind(address: Address): FundingRateModel {
    return new FundingRateModel("FundingRateModel", address);
  }

  FUNDING_RATE_PRECISION(): BigInt {
    let result = super.call(
      "FUNDING_RATE_PRECISION",
      "FUNDING_RATE_PRECISION():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_FUNDING_RATE_PRECISION(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "FUNDING_RATE_PRECISION",
      "FUNDING_RATE_PRECISION():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  MAX_FUNDING_RATE(): BigInt {
    let result = super.call(
      "MAX_FUNDING_RATE",
      "MAX_FUNDING_RATE():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_MAX_FUNDING_RATE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "MAX_FUNDING_RATE",
      "MAX_FUNDING_RATE():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  MIN_FUNDING_RATE(): BigInt {
    let result = super.call(
      "MIN_FUNDING_RATE",
      "MIN_FUNDING_RATE():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_MIN_FUNDING_RATE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "MIN_FUNDING_RATE",
      "MIN_FUNDING_RATE():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  SKEW_SCALE(): BigInt {
    let result = super.call("SKEW_SCALE", "SKEW_SCALE():(uint256)", []);

    return result[0].toBigInt();
  }

  try_SKEW_SCALE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("SKEW_SCALE", "SKEW_SCALE():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getFundingMode(): i32 {
    let result = super.call("getFundingMode", "getFundingMode():(uint8)", []);

    return result[0].toI32();
  }

  try_getFundingMode(): ethereum.CallResult<i32> {
    let result = super.tryCall(
      "getFundingMode",
      "getFundingMode():(uint8)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  getFundingRatePrecision(): BigInt {
    let result = super.call(
      "getFundingRatePrecision",
      "getFundingRatePrecision():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_getFundingRatePrecision(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getFundingRatePrecision",
      "getFundingRatePrecision():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getNextFundingRate(
    prevState: FundingRateModel__getNextFundingRateInputPrevStateStruct,
    longOpenInterest: BigInt,
    shortOpenInterest: BigInt
  ): BigInt {
    let result = super.call(
      "getNextFundingRate",
      "getNextFundingRate((uint256,uint256,uint256,int256),uint256,uint256):(int256)",
      [
        ethereum.Value.fromTuple(prevState),
        ethereum.Value.fromUnsignedBigInt(longOpenInterest),
        ethereum.Value.fromUnsignedBigInt(shortOpenInterest)
      ]
    );

    return result[0].toBigInt();
  }

  try_getNextFundingRate(
    prevState: FundingRateModel__getNextFundingRateInputPrevStateStruct,
    longOpenInterest: BigInt,
    shortOpenInterest: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getNextFundingRate",
      "getNextFundingRate((uint256,uint256,uint256,int256),uint256,uint256):(int256)",
      [
        ethereum.Value.fromTuple(prevState),
        ethereum.Value.fromUnsignedBigInt(longOpenInterest),
        ethereum.Value.fromUnsignedBigInt(shortOpenInterest)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  maxFundingRate(): BigInt {
    let result = super.call("maxFundingRate", "maxFundingRate():(uint256)", []);

    return result[0].toBigInt();
  }

  try_maxFundingRate(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "maxFundingRate",
      "maxFundingRate():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  minFundingRate(): BigInt {
    let result = super.call("minFundingRate", "minFundingRate():(uint256)", []);

    return result[0].toBigInt();
  }

  try_minFundingRate(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "minFundingRate",
      "minFundingRate():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  minSkew(): BigInt {
    let result = super.call("minSkew", "minSkew():(uint256)", []);

    return result[0].toBigInt();
  }

  try_minSkew(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("minSkew", "minSkew():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class SetMinMaxFundingRateCall extends ethereum.Call {
  get inputs(): SetMinMaxFundingRateCall__Inputs {
    return new SetMinMaxFundingRateCall__Inputs(this);
  }

  get outputs(): SetMinMaxFundingRateCall__Outputs {
    return new SetMinMaxFundingRateCall__Outputs(this);
  }
}

export class SetMinMaxFundingRateCall__Inputs {
  _call: SetMinMaxFundingRateCall;

  constructor(call: SetMinMaxFundingRateCall) {
    this._call = call;
  }

  get min(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get max(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class SetMinMaxFundingRateCall__Outputs {
  _call: SetMinMaxFundingRateCall;

  constructor(call: SetMinMaxFundingRateCall) {
    this._call = call;
  }
}
